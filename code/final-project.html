<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>final-project</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="final-project_files/libs/clipboard/clipboard.min.js"></script>
<script src="final-project_files/libs/quarto-html/quarto.js"></script>
<script src="final-project_files/libs/quarto-html/popper.min.js"></script>
<script src="final-project_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="final-project_files/libs/quarto-html/anchor.min.js"></script>
<link href="final-project_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="final-project_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="final-project_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="final-project_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="final-project_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="final-project-covid-19-mortality-across-the-united-states" class="level2">
<h2 class="anchored" data-anchor-id="final-project-covid-19-mortality-across-the-united-states">Final Project: COVID-19 Mortality across the United States</h2>
<p><strong>Abstract</strong></p>
<p>The COVID-19 period was not a linear progression of mortality rates but rather followed a wave pattern including periods with high mortality weeks and recovery. Responses to the crisis varied across the country. In order to understand the extent of the effect of COVID-19, it is crucial to examine sub-national data instead of relying on single summary national statistics. States were differently affected by the crisis. In the first wave, New Jersey, Connecticut and Massachusetts were heavily impacted but were able to recover and see declining weekly mortality rates through the duration of the crisis. On the other hand, states like Kentucky and West Virginia were heavily impacted in the second and third waves and had increasing mortality in each subsequent wave. Regional comparisons show states in the southeast region to be most impacted. An analysis of the state level mortality rates reveals strong neighborhood effects and pandemic preparedness should be collaborative to account for the interstate connectivity. Additionally, varying levels of state level investment in health care infrastructure, vaccination rates and public health communication could account for the varying mortality rates across states.</p>
<p><strong>Introduction</strong></p>
<p>It is undeniable that the COVID-19 pandemic had widespread affects across the country and the world at large. In Tanzania, my country of origin, the government refused to acknowledge the existence of COVID-19 with detrimental effects on the nation. In parallel, the United States as a global destination was heavily impacted and responses differed depending on the state politics and health care systems. During the pandemic period starting in 2020, there was widespread fear, misinformation and disinformation. This was reflected both nationally and at the state level. States across the US had varying responses to the pandemic including both lockdown measures and vaccination coverage. This project aims to study COVID-19 mortality rates across the country in multiple ways. Firstly, the COVID-19 pandemic period will be divided into 4 waves to understand the period where mortality rates were highest. Secondly, state to state comparisons of the crisis will be carried out to get insight on whether some states fared better than others. Lastly, state to state comparisons across the waves will also be analyzed to understand how the progression of the crisis differs in different states.</p>
<p><strong>Methods</strong></p>
<p>This analysis relied on data from multiple sources that were processed and merged to create the final analytical dataset. Firstly, for the main outcome of COVID-19 deaths, data was pulled from the CDC’s API. Death data was reported for each week and state from March 2020 to December 2024, the first and latest death reports respectively. This data is collected through a combination of vital statistic systems and state and local health department reporting and verification. A regional crosswalk using definitions from the CDC 10 Public Health Service (PHS) was used to map each state to the respective regions.</p>
<p>Since states have varying population levels, a comparison of absolute death counts would be invalid in studying the impact of COVID-19 across varying states. Population data was pulled from the US Census API for 2020 – 2021 and supplemented with vintage US census estimates capturing 2022 and 2023. The US Census did not have 2024 populations therefore a simple linear regression model using the data from 2022 and 2023 was used to extrapolate 2024 population. This approach assumes a constant rate of change in population growth and does not capture non-linear trends and demographic shifts that could have impacted population. However, given that the span is one year, the assumption is reasonable since population shifts usually take much longer. The linear model is below:</p>
<p><span class="math inline">\(Population_{state}\)</span> = <span class="math inline">\(\beta_0\)</span> + <span class="math inline">\(\beta_1\)</span> <span class="math inline">\(Year_{state}\)</span></p>
<p>The study uses death rates per 100,000 to standardize mortality estimates across states. With 50 states and the data spanning 4 years, single summaries of mortality rates by state are often less helpful in identifying underlying patterns and trends. The study will rely primarily on different forms of data visualization including heatmaps, bar charts, boxplots and choropleth maps to identify trends and variations across states and periods. Since the analysis involves a spatial component of the effects of COVID-19, a shapefile of the United States was used to overlay mortality rates by state. Additionally, descriptive statistics including measures of central tendency as well as dispersion will also be utilized to add to the visualization.</p>
<p>To compare mortality rates across different periods of the pandemic, the measure of deaths per week per 100,000 was used to account for the varying number of weeks in each period. This will standardize the analysis and enable valid comparisons. The periods chosen are based on visual inspection of the mortality estimates over time capturing sharp increases in mortality indicating a new outbreak.</p>
<p><strong>Results</strong></p>
<p>The pandemic period between January 2020 to December 2024 was split into 4 waves shown in <strong>Figure 1</strong>. The first wave is 30 weeks long from March 2020 through September 2020. This wave begins on the first week with reported COVID deaths and ends right before the next spike in death rates on October 1. The second wave extends for 39 weeks from October through June 2021. This wave of the pandemic had the week with the highest mortality rate of just under 8 deaths per 100,000 in January 2020. The third wave begins on July 2021 and ends 39 weeks later in March 2022. This wave had two sharp increases and declines in mortality rates with the worst week in January 2022 with 6.2 deaths per 100,000. Lastly, the fourth wave has more stable weekly mortality rates ranging from 0 to 1 death per 100,000 between April 2022 to December 7<sup>th</sup> – the last reported death in the data.</p>
<p>The regional data in <strong>Appendix 1</strong> also displays similar trends with more granularity on the particular regions that are mainly responsible for the fluctuations noted in the national estimates. In the first wave, the New York, New Jersey, Puerto Rico and Virgin Island areas are the main contributors to the high mortality rate. In the second wave, this is replaced by Mountain states. In the third wave and fourth waves, the stark distinctions between the regions generally start to converge.</p>
<p><strong>Figure 1: National mortality rates (2020-2024)</strong></p>
<p><img src="../plots/national_rates.png" class="img-fluid"></p>
<p>State to state comparisons in each wave reveal large differences in mortality rates. <strong>Figures 2 and 3</strong> below visually show these disparities across states and waves. Starting from the first wave, New Jersey had the largest death rates at 5.2 deaths per week per 100,000 and Alaska had no deaths. The average weekly death rate in the first wave was 1.8 deaths per 100,000 with a standard deviation of 1.12 as seen in <strong>Table 1</strong>. The second and third highest mortality states in this wave are both in New England (Connecticut and Massachusetts) and had mortality rates larger than two times the standard deviation above the mean. Vermont, Maine and Wyoming were better than other states in this wave <strong>(See Appendix 2).</strong></p>
<p>In the second wave, all states were affected. South Dakota was affected most with a weekly death rate of 4.9 deaths per 100,000 and Hawaii was least impacted with 0.23 deaths per 100,000. The mean weekly death rate was 2.98 deaths per 100,000 with a standard deviation of 1.1. Oklahoma and North Dakota also had mortality rates similar to South Dakota while Vermont maintained low mortality rates seen in the first wave <strong>(See Appendix 3)</strong>.</p>
<p>In the third wave, West Virginia was most impacted with 5.6 deaths per week per 100,000 and Vermont was the least affected state. The mean weekly death rate was 2.97 deaths per 100,000 and a standard deviation of 1.09. There was a strong regional effect with states in the Southeast region like Kentucky, Tennessee and Minnesota heavily impacted compared to states in New England <strong>(See Appendix 4)</strong>.</p>
<p>Lastly, mortality levels in the last wave are much lower with Kentucky having the highest weekly mortality rate of 0.82 deaths per 100,000 while Alaska reported no COVID deaths in this period <strong>(See Appendix 5)</strong>.</p>
<p><strong>Figure 2: Mortality rates across states and waves (2020-2024)</strong></p>
<p><img src="../plots/waves_state.png" class="img-fluid"></p>
<p><strong>Figure 3: Mortality rates across states and waves: heatmap (2020-2024)</strong></p>
<p><img src="../plots/waves_heat.png" class="img-fluid"></p>
<p><strong>Table 1: Death rate per week per 100,000 statistics for each wave (2020-2024)</strong></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th>Wave 1</th>
<th>Wave 2</th>
<th>Wave 3</th>
<th>Wave 4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Mean (SD)</td>
<td>1.85</td>
<td>2.98</td>
<td>2.97</td>
<td>0.42</td>
</tr>
<tr class="even">
<td>Median</td>
<td>1.319</td>
<td>2.008</td>
<td>2.049</td>
<td>0.408</td>
</tr>
<tr class="odd">
<td>Minimum</td>
<td>1</td>
<td>1.234</td>
<td>1.084</td>
<td>0</td>
</tr>
<tr class="even">
<td>Maximum</td>
<td>5.2</td>
<td>4.9</td>
<td>5.6</td>
<td>0.8</td>
</tr>
<tr class="odd">
<td>Weeks</td>
<td>30</td>
<td>39</td>
<td>39</td>
<td>144</td>
</tr>
</tbody>
</table>
<p>Comparing one period to the next on a national level, <strong>Figure 3</strong> shows that Waves 2 and 3 were the most virulent given the stark contrast in color between those panels and Wave 1 and 4. Similarly <strong>Figure 4</strong> shows the median death rates increasing from Wave 1 to 2, stagnating from Wave 2 to 3 followed by a sharp decline in Wave 4. <strong>Table 1</strong> numerically displays the results with Wave 2 and 3 equally virulent with similar average and median weekly death rates. However, <strong>Figure 2</strong> shows state level comparisons indicating some states were actually worse off in the first wave like Massachusetts and Connecticut compared to Wave 2 and 3. This is evident in <strong>Figure 4</strong> showing the large number of outliers in Wave 1.</p>
<p><strong>Figure 4: Mortality rates across waves: heatmap (2020-2024)</strong></p>
<p><img src="../plots/week_box.png" class="img-fluid"></p>
<p><strong>Discussion</strong></p>
<p>The results reveal large differences in mortality rates not only between states but across the 4 waves. Firstly, given the highly infectious nature of the disease there are obvious neighborhood effects across nearby states. This is evident across all waves. In the first wave for example, the hardest hit were New jersey and Connecticut. Both these places have a high proportion of commuters to New York city which had difficulty managing the pandemic. In that wave, Louisianna and Mississippi bordering states were also heavily hit with the fourth and fifth highest weekly mortality rates. In the first wave, the mean deathly rate was higher than the median pointing to a left-skewed distribution and the strong influence of the outliers mentioned. Given the interactions across states, pandemic preparedness strategies should prepare to co-ordinate across different state-level authorities and provide coherent and clear messaging to mitigate the effects of an pandemic. In a similar vein, misinformation delivered by state officials have detrimental effects on people not only in their own jurisdiction but across the nation. Therefore, public health officials should work to create trusted, reliable and accessible information channels as well as advocate for appropriate safety measures in a pandemic since that has trickle down effects.</p>
<p>Secondly, the results also reveal differences in how states are able to cope with the pandemic over time. State to state analyses across the waves reveal these discrepancies. States like Massachusetts and Connecticut were able to recover progressively and have lower average death rates in each subsequent wave. In contrast, the situation in West Virginia and Kentucky worsened over time. This shows underlying health care disparities across the states in terms of the health care system infrastructure, ability to adapt to increasing demand for services as well as vaccination coverage (including booster shots). Vaccine coverage could be both a demand or supply side issue given the rise in vaccine hesitancy particularly around the COVID-19 vaccine. In either case, the pandemic highlighted serious shortcomings in the health care system that need to be strengthened for a better response.</p>
<p>Thirdly, despite the varying levels of mortality rates across the states, the data shows that all states were impacted at one point or another. States like Vermont, Alaska and Hawaii that are more isolated and were more protected than others from the spread of COVID by design also had an increase in mortality rates particularly from Wave 2 to 3. This was during the Delta variant and Omicron phases of the pandemic. These findings highlight the need for continuous surveillance from all states and necessity in increasing vaccination and booster shot rates given the risk of dangerous variants.</p>
<p>Lastly, sub-national analyses are crucial in setting health priorities for public health experts and revealing the disproportionate impact of COVID masked by national statistics. However, there are some challenges in comparing results across states given differences in reporting rates particularly due to political dynamics that could influence a state’s reporting. Additionally, the state level is arguably also too broad to have local level policy implications. Further research should be done with county or census-tract data as well as demographic information on race given the disproportional impact of COVID on already marginalized populations.</p>
<p>In conclusion, COVID-19 had a devastating effect on the whole nation. However, some states were more affected than others. Given the connectivity of the country and the world, it is crucial to have surveillance systems that are connected, up-to-date and reliable. Additionally, adequate investments in the health care system and public health communication should be made to prepare for future crises.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>